# Generate Migration - AIOS Developer Task

## Execution Dependencies
**Utils:** migration-generator

## Purpose
Generate migration scripts for framework version upgrades, ensuring safe and reversible transitions between AIOS-FULLSTACK versions.

## Command Pattern
```
*generate-migration <from-version> <to-version> [options]
```

## Parameters
- `from-version`: Source framework version (e.g., v4.31.0)
- `to-version`: Target framework version (e.g., v5.0.0)
- `options`: Migration generation configuration

### Options
- `--type <type>`: Migration type (auto, manual, hybrid)
- `--analyze-breaking`: Analyze breaking changes only
- `--generate-rollback`: Generate rollback script
- `--dry-run`: Preview migration without generating
- `--include-tests`: Generate migration tests
- `--output <path>`: Output directory for migration scripts

## Examples
```bash
# Generate auto migration script
*generate-migration v4.31.0 v5.0.0

# Generate with rollback script
*generate-migration v4.31.0 v5.0.0 --generate-rollback

# Analyze breaking changes only
*generate-migration v4.31.0 v5.0.0 --analyze-breaking

# Generate with tests
*generate-migration v4.31.0 v5.0.0 --include-tests --output migrations/

# Dry run preview
*generate-migration v4.31.0 v5.0.0 --dry-run
```

## Implementation

```javascript
const fs = require('fs').promises;
const path = require('path');
const chalk = require('chalk');

class GenerateMigrationTask {
  constructor() {
    this.taskName = 'generate-migration';
    this.description = 'Generate migration scripts for framework upgrades';
    this.rootPath = process.cwd();
    this.migrationGenerator = null;
  }

  async execute(params) {
    try {
      console.log(chalk.blue('üîß AIOS Migration Script Generator'));
      console.log(chalk.gray('Analyzing version changes and generating migration...\n'));

      // Parse parameters
      const config = await this.parseParameters(params);
      
      // Validate versions
      await this.validateVersions(config);
      
      // Initialize dependencies
      await this.initializeDependencies();

      // Generate migration script
      const result = await this.generateMigration(config);

      return {
        success: true,
        ...result
      };

    } catch (error) {
      console.error(chalk.red(`\n‚ùå Migration generation failed: ${error.message}`));
      throw error;
    }
  }

  async parseParameters(params) {
    if (params.length < 2) {
      throw new Error('Usage: *generate-migration <from-version> <to-version> [options]');
    }

    const config = {
      fromVersion: params[0],
      toVersion: params[1],
      type: 'auto',
      analyzeBreaking: false,
      generateRollback: false,
      dryRun: false,
      includeTests: false,
      output: path.join(this.rootPath, 'migrations')
    };

    for (let i = 2; i < params.length; i++) {
      const param = params[i];

      if (param === '--analyze-breaking') {
        config.analyzeBreaking = true;
      } else if (param === '--generate-rollback') {
        config.generateRollback = true;
      } else if (param === '--dry-run') {
        config.dryRun = true;
      } else if (param === '--include-tests') {
        config.includeTests = true;
      } else if (param === '--type' && params[i + 1]) {
        config.type = params[++i];
      } else if (param === '--output' && params[i + 1]) {
        config.output = params[++i];
      }
    }

    return config;
  }

  async validateVersions(config) {
    const versionPattern = /^v?\d+\.\d+\.\d+$/;
    
    if (!versionPattern.test(config.fromVersion)) {
      throw new Error(`Invalid source version: ${config.fromVersion}`);
    }
    
    if (!versionPattern.test(config.toVersion)) {
      throw new Error(`Invalid target version: ${config.toVersion}`);
    }

    console.log(chalk.blue(`Migration: ${config.fromVersion} ‚Üí ${config.toVersion}\n`));
  }

  async initializeDependencies() {
    try {
      const MigrationGenerator = require('../scripts/migration-generator');
      this.migrationGenerator = new MigrationGenerator({ rootPath: this.rootPath });
    } catch (error) {
      throw new Error(`Failed to initialize migration-generator: ${error.message}`);
    }
  }

  async generateMigration(config) {
    console.log(chalk.blue('üìä Analyzing version changes...\n'));
    
    const migrationScript = await this.migrationGenerator.generateMigrationScript(
      config.fromVersion,
      config.toVersion,
      { migrationType: config.type }
    );

    if (config.dryRun) {
      return await this.previewMigration(migrationScript, config);
    } else {
      return await this.saveMigration(migrationScript, config);
    }
  }

  async previewMigration(migrationScript, config) {
    console.log(chalk.yellow('üîç Migration Preview (Dry Run)\n'));
    console.log(chalk.gray('‚îÄ'.repeat(60)));
    
    console.log(chalk.yellow('Migration Operations:'));
    for (const op of migrationScript.operations) {
      console.log(`  - ${op.type}: ${op.description}`);
    }
    
    console.log(chalk.gray('\nEstimated Duration:'), migrationScript.estimated_duration);
    console.log(chalk.gray('Risk Level:'), migrationScript.risk_level);
    
    if (migrationScript.prerequisites.length > 0) {
      console.log(chalk.yellow('\nPrerequisites:'));
      for (const prereq of migrationScript.prerequisites) {
        console.log(`  - ${prereq}`);
      }
    }

    console.log(chalk.gray('‚îÄ'.repeat(60)));
    console.log(chalk.blue('\nüí° Run without --dry-run to generate migration files'));

    return {
      preview: true,
      migrationScript
    };
  }

  async saveMigration(migrationScript, config) {
    // Ensure output directory exists
    await fs.mkdir(config.output, { recursive: true });

    const migrationId = migrationScript.migration_id;
    const migrationFile = path.join(config.output, `${migrationId}.js`);
    
    // Generate migration script file
    const scriptContent = this.generateScriptContent(migrationScript);
    await fs.writeFile(migrationFile, scriptContent);
    
    console.log(chalk.green(`‚úÖ Migration script created: ${migrationFile}`));

    // Generate rollback script if requested
    if (config.generateRollback) {
      const rollbackFile = path.join(config.output, `${migrationId}-rollback.js`);
      const rollbackContent = this.generateRollbackContent(migrationScript);
      await fs.writeFile(rollbackFile, rollbackContent);
      console.log(chalk.green(`‚úÖ Rollback script created: ${rollbackFile}`));
    }

    // Generate tests if requested
    if (config.includeTests) {
      const testFile = path.join(config.output, `${migrationId}.test.js`);
      const testContent = this.generateTestContent(migrationScript);
      await fs.writeFile(testFile, testContent);
      console.log(chalk.green(`‚úÖ Migration tests created: ${testFile}`));
    }

    // Display summary
    console.log(chalk.blue('\nüìã Migration Summary:'));
    console.log(`  From: ${config.fromVersion}`);
    console.log(`  To: ${config.toVersion}`);
    console.log(`  Operations: ${migrationScript.operations.length}`);
    console.log(`  Risk Level: ${migrationScript.risk_level}`);
    console.log(`  Estimated Duration: ${migrationScript.estimated_duration}`);

    return {
      generated: true,
      migrationFile,
      migrationScript
    };
  }

  generateScriptContent(migrationScript) {
    return `/**
 * AIOS-FULLSTACK Migration Script
 * 
 * Migration: ${migrationScript.migration_id}
 * From: ${migrationScript.from_version}
 * To: ${migrationScript.to_version}
 * Generated: ${migrationScript.timestamp}
 * 
 * IMPORTANT: Review this migration carefully before execution
 * Test in development environment before production
 */

module.exports = {
  id: '${migrationScript.migration_id}',
  fromVersion: '${migrationScript.from_version}',
  toVersion: '${migrationScript.to_version}',
  riskLevel: '${migrationScript.risk_level}',
  estimatedDuration: ${migrationScript.estimated_duration},
  
  async up() {
    console.log('Running migration: ${migrationScript.migration_id}');
    
    ${migrationScript.operations.map(op => `
    // ${op.description}
    // Type: ${op.type}
    // TODO: Implement operation`).join('\n')}
    
    console.log('Migration completed successfully');
  },
  
  async down() {
    console.log('Rolling back migration: ${migrationScript.migration_id}');
    
    ${migrationScript.rollback_operations.map(op => `
    // Rollback: ${op.description}
    // TODO: Implement rollback`).join('\n')}
    
    console.log('Rollback completed successfully');
  },
  
  validate() {
    ${migrationScript.validation_checks.map(check => `
    // Validation: ${check}
    // TODO: Implement validation`).join('\n')}
    
    return true;
  }
};
`;
  }

  generateRollbackContent(migrationScript) {
    return `/**
 * AIOS-FULLSTACK Rollback Script
 * 
 * Rollback for: ${migrationScript.migration_id}
 * From: ${migrationScript.to_version}
 * Back To: ${migrationScript.from_version}
 */

module.exports = require('./${migrationScript.migration_id}').down;
`;
  }

  generateTestContent(migrationScript) {
    return `/**
 * Migration Tests: ${migrationScript.migration_id}
 */

const migration = require('./${migrationScript.migration_id}');

describe('Migration ${migrationScript.migration_id}', () => {
  test('validates successfully', () => {
    expect(migration.validate()).toBe(true);
  });
  
  test('can run up migration', async () => {
    await expect(migration.up()).resolves.not.toThrow();
  });
  
  test('can run down migration', async () => {
    await expect(migration.down()).resolves.not.toThrow();
  });
});
`;
  }
}

module.exports = GenerateMigrationTask;
```

## Integration Points

### Migration Generator
- Analyzes version changes
- Generates migration operations
- Plans rollback procedures
- Assesses migration risk

### Version Tracking
- Detects version differences
- Identifies breaking changes
- Tracks migration history

### Framework Analysis
- Analyzes framework structure changes
- Identifies affected components
- Detects API changes

## Migration Types

### Auto Migration
- Automatically generated from version analysis
- Safe for non-breaking changes
- Minimal manual intervention

### Manual Migration
- Requires developer review and customization
- For complex breaking changes
- Full control over migration steps

### Hybrid Migration
- Mix of automatic and manual steps
- Auto-generates safe operations
- Flags complex changes for manual handling

## Best Practices

### Before Migration
- Review migration script thoroughly
- Test in development environment
- Backup production data
- Verify rollback procedures

### During Migration
- Monitor progress closely
- Watch for errors
- Have rollback ready
- Document any issues

### After Migration
- Validate all functionality
- Run comprehensive tests
- Update documentation
- Monitor production metrics

