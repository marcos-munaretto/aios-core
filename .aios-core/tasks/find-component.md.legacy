# Find Component - AIOS Developer Task

## Execution Dependencies
**Utils:** component-search

## Purpose
Search and discover existing framework components (agents, tasks, workflows, utilities) by name, capability, or functionality.

## Command Pattern
```
*find-component <search-query> [options]
```

## Parameters
- `search-query`: Search term or pattern to find components
- `options`: Search configuration and filters

### Options
- `--type <types>`: Component types to search (agent,task,workflow,util)
- `--capability <caps>`: Filter by capabilities
- `--tags <tags>`: Filter by tags
- `--fuzzy`: Enable fuzzy matching
- `--limit <n>`: Max results to return (default: 10)
- `--output <format>`: Output format (list, table, json, detailed)
- `--show-path`: Show file paths in results
- `--show-deps`: Show component dependencies

## Examples
```bash
# Search for authentication-related components
*find-component authentication

# Find all agents
*find-component --type agent

# Find utilities related to git
*find-component git --type util

# Fuzzy search for commit-related components
*find-component comit --fuzzy

# Detailed search with dependencies
*find-component validation --show-deps --output detailed

# Find components by capability
*find-component --capability "code-generation"

# Search with multiple types
*find-component sync --type task,util --limit 5
```

## Implementation

```javascript
const fs = require('fs').promises;
const path = require('path');
const chalk = require('chalk');

class FindComponentTask {
  constructor() {
    this.taskName = 'find-component';
    this.description = 'Search and discover framework components';
    this.rootPath = process.cwd();
    this.componentSearch = null;
  }

  async execute(params) {
    try {
      console.log(chalk.blue('ğŸ” AIOS Component Search'));
      console.log(chalk.gray('Searching framework components...\n'));

      // Parse parameters
      const config = await this.parseParameters(params);
      
      if (!config.query && !config.type && !config.capability) {
        throw new Error('Provide a search query, --type, or --capability');
      }

      // Initialize dependencies
      await this.initializeDependencies();

      // Perform search
      const results = await this.searchComponents(config);

      // Display results
      await this.displayResults(results, config);

      return {
        success: true,
        resultsCount: results.length,
        results: results.map(r => ({ type: r.type, name: r.name, path: r.path }))
      };

    } catch (error) {
      console.error(chalk.red(`\nâŒ Search failed: ${error.message}`));
      throw error;
    }
  }

  async parseParameters(params) {
    const config = {
      query: null,
      types: [],
      capability: null,
      tags: [],
      fuzzy: false,
      limit: 10,
      output: 'list',
      showPath: false,
      showDeps: false
    };

    for (let i = 0; i < params.length; i++) {
      const param = params[i];

      if (param === '--fuzzy') {
        config.fuzzy = true;
      } else if (param === '--show-path') {
        config.showPath = true;
      } else if (param === '--show-deps') {
        config.showDeps = true;
      } else if (param === '--type' && params[i + 1]) {
        config.types = params[++i].split(',').map(t => t.trim());
      } else if (param === '--capability' && params[i + 1]) {
        config.capability = params[++i];
      } else if (param === '--tags' && params[i + 1]) {
        config.tags = params[++i].split(',').map(t => t.trim());
      } else if (param === '--limit' && params[i + 1]) {
        config.limit = parseInt(params[++i], 10);
      } else if (param === '--output' && params[i + 1]) {
        config.output = params[++i];
      } else if (!param.startsWith('--')) {
        config.query = param;
      }
    }

    // Validate types
    const validTypes = ['agent', 'task', 'workflow', 'util'];
    for (const type of config.types) {
      if (!validTypes.includes(type)) {
        throw new Error(`Invalid component type: ${type}`);
      }
    }

    return config;
  }

  async initializeDependencies() {
    try {
      const ComponentSearch = require('../scripts/component-search');
      this.componentSearch = new ComponentSearch({ rootPath: this.rootPath });
      await this.componentSearch.initialize();
    } catch (error) {
      throw new Error(`Failed to initialize component-search: ${error.message}`);
    }
  }

  async searchComponents(config) {
    const searchOptions = {
      types: config.types.length > 0 ? config.types : undefined,
      capability: config.capability,
      tags: config.tags.length > 0 ? config.tags : undefined,
      fuzzy: config.fuzzy,
      limit: config.limit
    };

    if (config.query) {
      return await this.componentSearch.search(config.query, searchOptions);
    } else {
      return await this.componentSearch.filter(searchOptions);
    }
  }

  async displayResults(results, config) {
    if (results.length === 0) {
      console.log(chalk.yellow('No components found matching your criteria'));
      return;
    }

    console.log(chalk.blue(`\nğŸ“‹ Found ${results.length} component${results.length !== 1 ? 's' : ''}:\n`));

    switch (config.output) {
      case 'list':
        this.displayListFormat(results, config);
        break;
      case 'table':
        this.displayTableFormat(results, config);
        break;
      case 'json':
        console.log(JSON.stringify(results, null, 2));
        break;
      case 'detailed':
        await this.displayDetailedFormat(results, config);
        break;
      default:
        this.displayListFormat(results, config);
    }
  }

  displayListFormat(results, config) {
    for (const result of results) {
      const icon = this.getTypeIcon(result.type);
      const name = chalk.cyan(result.name);
      const type = chalk.gray(`[${result.type}]`);
      
      console.log(`${icon} ${name} ${type}`);
      
      if (result.title) {
        console.log(chalk.gray(`   ${result.title}`));
      }
      
      if (config.showPath) {
        console.log(chalk.gray(`   Path: ${result.path}`));
      }
      
      if (result.matchReason) {
        console.log(chalk.gray(`   Match: ${result.matchReason}`));
      }
      
      console.log('');
    }
  }

  displayTableFormat(results, config) {
    const rows = results.map(r => ({
      Type: this.getTypeIcon(r.type) + ' ' + r.type,
      Name: r.name,
      Title: (r.title || '').substring(0, 40),
      ...(config.showPath ? { Path: path.basename(r.path) } : {})
    }));

    console.table(rows);
  }

  async displayDetailedFormat(results, config) {
    for (let i = 0; i < results.length; i++) {
      const result = results[i];
      const icon = this.getTypeIcon(result.type);
      
      console.log(chalk.blue(`\n${icon} ${result.name}`));
      console.log(chalk.gray('â”€'.repeat(60)));
      
      console.log(chalk.yellow('Type:'), result.type);
      if (result.title) console.log(chalk.yellow('Title:'), result.title);
      if (result.whenToUse) console.log(chalk.yellow('When to Use:'), result.whenToUse);
      if (result.description) console.log(chalk.yellow('Description:'), result.description);
      
      if (config.showPath) {
        console.log(chalk.yellow('Path:'), result.path);
      }
      
      if (config.showDeps && result.dependencies) {
        console.log(chalk.yellow('Dependencies:'));
        for (const [depType, deps] of Object.entries(result.dependencies)) {
          if (deps && deps.length > 0) {
            console.log(`  ${depType}: ${deps.join(', ')}`);
          }
        }
      }
      
      if (result.capabilities && result.capabilities.length > 0) {
        console.log(chalk.yellow('Capabilities:'), result.capabilities.join(', '));
      }
      
      if (result.tags && result.tags.length > 0) {
        console.log(chalk.yellow('Tags:'), result.tags.join(', '));
      }
    }
  }

  getTypeIcon(type) {
    const icons = {
      agent: 'ğŸ¤–',
      task: 'ğŸ“‹',
      workflow: 'ğŸ”„',
      util: 'ğŸ”§',
      template: 'ğŸ“„',
      data: 'ğŸ“Š'
    };
    return icons[type] || 'ğŸ“¦';
  }
}

module.exports = FindComponentTask;
```

## Integration Points

### Component Search
- Indexes all framework components
- Supports multi-field search
- Fuzzy matching with similarity scores
- Filters by type, capability, tags
- Caches search index for performance

### Component Types
- **Agents**: AI agents with specific roles and capabilities
- **Tasks**: Executable workflow tasks
- **Workflows**: Multi-step process definitions
- **Utils**: Utility scripts and helper functions
- **Templates**: Document and code templates
- **Data**: Reference data and knowledge base

### Search Strategies
- **Name matching**: Component ID and display name
- **Title matching**: Component title and description
- **Content search**: Full-text search in component files
- **Capability search**: Match by declared capabilities
- **Tag search**: Filter by assigned tags
- **Fuzzy matching**: Typo-tolerant search

## Search Index

### Indexed Fields
- Component ID
- Display name
- Title
- Description
- When to use
- Capabilities
- Tags
- Dependencies
- File path

### Index Update
- Auto-update on file changes
- Manual refresh via component-search
- Background indexing for performance

## Output Formats

### List Format
```
ğŸ¤– dev [agent]
   Full Stack Developer
   Path: aios-core/agents/dev.md

ğŸ”§ batch-creator [util]
   Creates batches of related tasks
```

### Table Format
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Type   â”‚ Name        â”‚ Title              â”‚ Path      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ¤– agentâ”‚ dev        â”‚ Full Stack...      â”‚ dev.md    â”‚
â”‚ ğŸ”§ util â”‚ batch-creatorâ”‚ Creates batches...â”‚ batch...  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### JSON Format
```json
[
  {
    "type": "agent",
    "name": "dev",
    "title": "Full Stack Developer",
    "path": "aios-core/agents/dev.md",
    "capabilities": ["coding", "debugging"],
    "dependencies": {
      "utils": ["batch-creator", "code-quality-improver"]
    }
  }
]
```

## Best Practices

### Effective Searching
- Start with broad terms, then narrow
- Use --type to filter by component type
- Try fuzzy search for typo tolerance
- Use --capability for functional search
- Combine multiple filters for precision

### Component Discovery
- Use find-component to explore framework
- Check dependencies before using
- Review "when to use" guidance
- Understand component capabilities
- Read component documentation

### Integration Workflow
1. Find component with find-component
2. Review component details (--output detailed)
3. Check dependencies (--show-deps)
4. Read component documentation
5. Add to agent/task dependencies
6. Test integration

