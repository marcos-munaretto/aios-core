# Generate Commit Message - AIOS Developer Task

## Execution Dependencies
**Utils:** commit-message-generator

## Purpose
Generate semantic commit messages following conventional commit standards by analyzing staged git changes.

## Command Pattern
```
*generate-commit-message [options]
```

## Parameters
- `options`: Message generation configuration

### Options
- `--type <type>`: Commit type (feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert)
- `--scope <scope>`: Commit scope (component/module affected)
- `--breaking`: Mark as breaking change
- `--interactive`: Interactive mode for reviewing and editing
- `--auto-commit`: Auto-commit after generation
- `--include-body`: Include detailed body in message
- `--include-footer`: Include footer with issues/PRs

## Examples
```bash
# Generate message interactively
*generate-commit-message --interactive

# Generate feat message with scope
*generate-commit-message --type feat --scope agent-dev

# Generate fix message and auto-commit
*generate-commit-message --type fix --auto-commit

# Generate with breaking change marker
*generate-commit-message --type refactor --breaking --interactive

# Full message with body and footer
*generate-commit-message --interactive --include-body --include-footer
```

## Implementation

```javascript
const fs = require('fs').promises;
const path = require('path');
const chalk = require('chalk');
const inquirer = require('inquirer');
const { execSync } = require('child_process');

class GenerateCommitMessageTask {
  constructor() {
    this.taskName = 'generate-commit-message';
    this.description = 'Generate semantic commit messages from git changes';
    this.rootPath = process.cwd();
    this.commitMessageGenerator = null;
  }

  async execute(params) {
    try {
      console.log(chalk.blue('üìù AIOS Semantic Commit Message Generator'));
      console.log(chalk.gray('Analyzing staged changes...\n'));

      // Check for staged changes
      const hasStagedChanges = await this.checkStagedChanges();
      if (!hasStagedChanges) {
        console.log(chalk.yellow('‚ö†Ô∏è  No staged changes found'));
        console.log(chalk.gray('Use: git add <files> to stage changes'));
        return { success: false, reason: 'no_staged_changes' };
      }

      // Parse parameters
      const config = await this.parseParameters(params);
      
      // Initialize dependencies
      await this.initializeDependencies();

      // Generate commit message
      const message = await this.generateMessage(config);

      if (config.autoCommit) {
        await this.performCommit(message);
      } else {
        await this.displayMessage(message, config);
      }

      return {
        success: true,
        message,
        committed: config.autoCommit
      };

    } catch (error) {
      console.error(chalk.red(`\n‚ùå Failed to generate commit message: ${error.message}`));
      throw error;
    }
  }

  async parseParameters(params) {
    const config = {
      type: null,
      scope: null,
      breaking: false,
      interactive: false,
      autoCommit: false,
      includeBody: false,
      includeFooter: false
    };

    for (let i = 0; i < params.length; i++) {
      const param = params[i];

      if (param === '--interactive') {
        config.interactive = true;
      } else if (param === '--breaking') {
        config.breaking = true;
      } else if (param === '--auto-commit') {
        config.autoCommit = true;
      } else if (param === '--include-body') {
        config.includeBody = true;
      } else if (param === '--include-footer') {
        config.includeFooter = true;
      } else if (param === '--type' && params[i + 1]) {
        config.type = params[++i];
      } else if (param === '--scope' && params[i + 1]) {
        config.scope = params[++i];
      }
    }

    return config;
  }

  async checkStagedChanges() {
    try {
      const status = execSync('git status --porcelain', { encoding: 'utf8' });
      const staged = status.split('\n').filter(line => line.match(/^[MADRC]/));
      return staged.length > 0;
    } catch (error) {
      throw new Error('Failed to check git status. Are you in a git repository?');
    }
  }

  async initializeDependencies() {
    try {
      const CommitMessageGenerator = require('../scripts/commit-message-generator');
      this.commitMessageGenerator = new CommitMessageGenerator();
    } catch (error) {
      throw new Error(`Failed to initialize commit-message-generator: ${error.message}`);
    }
  }

  async generateMessage(config) {
    // Get diff of staged changes
    const diff = execSync('git diff --cached', { encoding: 'utf8' });
    
    if (config.interactive) {
      return await this.interactiveGeneration(diff, config);
    } else {
      return await this.automaticGeneration(diff, config);
    }
  }

  async interactiveGeneration(diff, config) {
    console.log(chalk.blue('üìä Analyzing changes...\n'));
    
    // Analyze changes
    const analysis = await this.commitMessageGenerator.analyzeChanges(diff);
    
    // Display analysis summary
    console.log(chalk.gray('Changed files:'));
    for (const file of analysis.files.slice(0, 5)) {
      console.log(`  - ${file.path} (${file.additions}+, ${file.deletions}-)`);
    }
    if (analysis.files.length > 5) {
      console.log(chalk.gray(`  ... and ${analysis.files.length - 5} more files`));
    }
    console.log('');

    // Suggest commit type
    const suggestedType = analysis.suggestedType || 'feat';
    const suggestedScope = analysis.suggestedScope || null;

    // Interactive prompts
    const answers = await inquirer.prompt([
      {
        type: 'list',
        name: 'type',
        message: 'Select commit type:',
        default: config.type || suggestedType,
        choices: [
          { name: 'feat: A new feature', value: 'feat' },
          { name: 'fix: A bug fix', value: 'fix' },
          { name: 'docs: Documentation changes', value: 'docs' },
          { name: 'style: Code style changes (formatting)', value: 'style' },
          { name: 'refactor: Code refactoring', value: 'refactor' },
          { name: 'perf: Performance improvements', value: 'perf' },
          { name: 'test: Test changes', value: 'test' },
          { name: 'build: Build system changes', value: 'build' },
          { name: 'ci: CI configuration changes', value: 'ci' },
          { name: 'chore: Other changes', value: 'chore' }
        ]
      },
      {
        type: 'input',
        name: 'scope',
        message: 'Commit scope (optional):',
        default: config.scope || suggestedScope || ''
      },
      {
        type: 'input',
        name: 'subject',
        message: 'Commit subject (short description):',
        default: analysis.suggestedSubject || '',
        validate: (input) => input.length > 0 && input.length <= 72
      },
      {
        type: 'confirm',
        name: 'breaking',
        message: 'Is this a breaking change?',
        default: config.breaking,
        when: () => !config.breaking
      },
      {
        type: 'confirm',
        name: 'includeBody',
        message: 'Include detailed body?',
        default: config.includeBody,
        when: () => !config.includeBody
      },
      {
        type: 'editor',
        name: 'body',
        message: 'Commit body (detailed description):',
        default: analysis.suggestedBody || '',
        when: (answers) => answers.includeBody || config.includeBody
      },
      {
        type: 'confirm',
        name: 'includeFooter',
        message: 'Include footer (issues/PRs)?',
        default: config.includeFooter,
        when: () => !config.includeFooter
      },
      {
        type: 'input',
        name: 'footer',
        message: 'Footer (e.g., Closes #123, Refs #456):',
        when: (answers) => answers.includeFooter || config.includeFooter
      }
    ]);

    // Build commit message
    return this.commitMessageGenerator.buildMessage(answers);
  }

  async automaticGeneration(diff, config) {
    const analysis = await this.commitMessageGenerator.analyzeChanges(diff);
    
    const messageConfig = {
      type: config.type || analysis.suggestedType || 'feat',
      scope: config.scope || analysis.suggestedScope,
      subject: analysis.suggestedSubject,
      breaking: config.breaking,
      body: config.includeBody ? analysis.suggestedBody : null,
      footer: config.includeFooter ? analysis.suggestedFooter : null
    };

    return this.commitMessageGenerator.buildMessage(messageConfig);
  }

  async displayMessage(message, config) {
    console.log(chalk.blue('\nüìù Generated Commit Message:\n'));
    console.log(chalk.green('‚îÄ'.repeat(60)));
    console.log(message);
    console.log(chalk.green('‚îÄ'.repeat(60)));

    const { action } = await inquirer.prompt([
      {
        type: 'list',
        name: 'action',
        message: 'What would you like to do?',
        choices: [
          { name: 'Copy to clipboard', value: 'copy' },
          { name: 'Commit with this message', value: 'commit' },
          { name: 'Edit message', value: 'edit' },
          { name: 'Cancel', value: 'cancel' }
        ]
      }
    ]);

    if (action === 'commit') {
      await this.performCommit(message);
    } else if (action === 'copy') {
      // Copy to clipboard (platform-specific)
      console.log(chalk.green('‚úÖ Message ready to paste'));
    } else if (action === 'edit') {
      const { edited } = await inquirer.prompt([
        {
          type: 'editor',
          name: 'edited',
          message: 'Edit commit message:',
          default: message
        }
      ]);
      await this.performCommit(edited);
    }
  }

  async performCommit(message) {
    try {
      // Write message to temp file
      const tempFile = path.join(this.rootPath, '.git', 'COMMIT_EDITMSG_TEMP');
      await fs.writeFile(tempFile, message);

      // Perform commit
      execSync(`git commit -F "${tempFile}"`, { stdio: 'inherit' });
      
      // Clean up
      await fs.unlink(tempFile);

      console.log(chalk.green('\n‚úÖ Changes committed successfully!'));
    } catch (error) {
      throw new Error(`Failed to commit: ${error.message}`);
    }
  }
}

module.exports = GenerateCommitMessageTask;
```

## Integration Points

### Commit Message Generator
- Analyzes git diff output
- Detects change patterns
- Suggests commit types and scopes
- Builds conventional commit messages

### Git Integration
- Reads staged changes via `git diff --cached`
- Performs commits via `git commit`
- Validates commit message format

### Conventional Commits Standard
- **Type**: feat, fix, docs, style, refactor, perf, test, build, ci, chore
- **Scope**: Component or module affected (optional)
- **Subject**: Short description (max 72 chars)
- **Body**: Detailed description (optional)
- **Footer**: Issue references, breaking changes (optional)

## Message Format

### Basic Format
```
<type>(<scope>): <subject>
```

### With Breaking Change
```
<type>(<scope>)!: <subject>

BREAKING CHANGE: Description of breaking change
```

### Full Format
```
<type>(<scope>): <subject>

<body>

<footer>
```

## Examples

### Feature Commit
```
feat(agent-dev): add utility integration support

Integrate 23 utility scripts into framework agents. Utilities now
discoverable through agent dependencies and documented in README.

Closes #3.4
```

### Bug Fix
```
fix(commit-generator): correct scope detection

Fix regex pattern for detecting component scopes in file paths.
```

### Breaking Change
```
refactor(api)!: change authentication method

BREAKING CHANGE: Replace API key auth with OAuth2.
Update all API clients to use new auth flow.

Migration guide: docs/migration/oauth2.md
```

## Best Practices

### Message Quality
- Use imperative mood ("add" not "added")
- Keep subject under 72 characters
- Capitalize subject
- No period at end of subject
- Blank line between subject and body
- Wrap body at 72 characters

### Scope Selection
- Use component/module name
- Keep scope short and clear
- Be consistent across project
- Use scope hierarchy if needed

### Breaking Changes
- Always mark with `!` or `BREAKING CHANGE:`
- Describe what broke
- Explain migration path
- Reference migration docs

