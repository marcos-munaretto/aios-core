# Rollback Modification - AIOS Developer Task

## Execution Dependencies
**Utils:** rollback-handler

## Purpose
Safely rollback framework modifications when issues are detected, restoring previous working state with complete audit trail.

## Command Pattern
```
*rollback-modification <modification-id> [options]
```

## Parameters
- `modification-id`: ID of modification to rollback
- `options`: Rollback configuration

### Options
- `--confirm`: Skip confirmation prompt
- `--partial`: Rollback specific files only
- `--preserve-backup`: Keep backup files after rollback
- `--verify`: Verify rollback integrity
- `--checkpoint <name>`: Rollback to named checkpoint
- `--list-modifications`: List available modifications to rollback

## Examples
```bash
# List recent modifications
*rollback-modification --list-modifications

# Rollback specific modification
*rollback-modification mod-20251029-abc123

# Rollback with verification
*rollback-modification mod-20251029-abc123 --verify

# Rollback to checkpoint
*rollback-modification --checkpoint pre-story-3.5

# Partial rollback (specific files)
*rollback-modification mod-20251029-abc123 --partial

# Rollback with confirmation skip
*rollback-modification mod-20251029-abc123 --confirm --verify
```

## Implementation

```javascript
const fs = require('fs').promises;
const path = require('path');
const chalk = require('chalk');
const inquirer = require('inquirer');

class RollbackModificationTask {
  constructor() {
    this.taskName = 'rollback-modification';
    this.description = 'Rollback framework modifications safely';
    this.rootPath = process.cwd();
    this.rollbackHandler = null;
  }

  async execute(params) {
    try {
      console.log(chalk.blue('‚èÆÔ∏è  AIOS Framework Modification Rollback'));
      console.log(chalk.gray('Safely reverting framework changes...\n'));

      // Parse parameters
      const config = await this.parseParameters(params);
      
      // Initialize dependencies
      await this.initializeDependencies();

      // List modifications if requested
      if (config.listModifications) {
        return await this.listModifications();
      }

      // Validate modification exists
      await this.validateModification(config);
      
      // Confirm rollback
      if (!config.confirm) {
        const confirmed = await this.confirmRollback(config);
        if (!confirmed) {
          console.log(chalk.yellow('Rollback cancelled by user'));
          return { success: false, cancelled: true };
        }
      }

      // Execute rollback
      const result = await this.performRollback(config);

      return {
        success: true,
        ...result
      };

    } catch (error) {
      console.error(chalk.red(`\n‚ùå Rollback failed: ${error.message}`));
      throw error;
    }
  }

  async parseParameters(params) {
    const config = {
      modificationId: null,
      confirm: false,
      partial: false,
      preserveBackup: false,
      verify: false,
      checkpoint: null,
      listModifications: false
    };

    for (let i = 0; i < params.length; i++) {
      const param = params[i];

      if (param === '--confirm') {
        config.confirm = true;
      } else if (param === '--partial') {
        config.partial = true;
      } else if (param === '--preserve-backup') {
        config.preserveBackup = true;
      } else if (param === '--verify') {
        config.verify = true;
      } else if (param === '--list-modifications') {
        config.listModifications = true;
      } else if (param === '--checkpoint' && params[i + 1]) {
        config.checkpoint = params[++i];
      } else if (!param.startsWith('--')) {
        config.modificationId = param;
      }
    }

    if (!config.listModifications && !config.modificationId && !config.checkpoint) {
      throw new Error('Provide modification ID, checkpoint, or use --list-modifications');
    }

    return config;
  }

  async initializeDependencies() {
    try {
      const RollbackHandler = require('../scripts/rollback-handler');
      this.rollbackHandler = new RollbackHandler({ rootPath: this.rootPath });
      await this.rollbackHandler.initialize();
    } catch (error) {
      throw new Error(`Failed to initialize rollback-handler: ${error.message}`);
    }
  }

  async listModifications() {
    console.log(chalk.blue('üìã Recent Modifications:\n'));
    
    const modifications = await this.rollbackHandler.getModificationHistory();
    
    if (modifications.length === 0) {
      console.log(chalk.gray('No modifications found'));
      return { modifications: [] };
    }

    for (const mod of modifications.slice(0, 10)) {
      console.log(chalk.yellow(`ID: ${mod.id}`));
      console.log(`  Date: ${new Date(mod.timestamp).toLocaleString()}`);
      console.log(`  Type: ${mod.type}`);
      console.log(`  Files: ${mod.files.length}`);
      console.log(`  Description: ${mod.description || 'N/A'}`);
      console.log('');
    }

    return { modifications };
  }

  async validateModification(config) {
    const modId = config.modificationId || config.checkpoint;
    const exists = await this.rollbackHandler.modificationExists(modId);
    
    if (!exists) {
      throw new Error(`Modification not found: ${modId}`);
    }
  }

  async confirmRollback(config) {
    const modId = config.modificationId || config.checkpoint;
    const modInfo = await this.rollbackHandler.getModificationInfo(modId);
    
    console.log(chalk.yellow('‚ö†Ô∏è  Rollback Confirmation\n'));
    console.log(chalk.gray('Modification Details:'));
    console.log(`  ID: ${modInfo.id}`);
    console.log(`  Type: ${modInfo.type}`);
    console.log(`  Files affected: ${modInfo.files.length}`);
    console.log(`  Date: ${new Date(modInfo.timestamp).toLocaleString()}`);
    console.log('');

    const { confirmed } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'confirmed',
        message: 'Proceed with rollback?',
        default: false
      }
    ]);

    return confirmed;
  }

  async performRollback(config) {
    const modId = config.modificationId || config.checkpoint;
    
    console.log(chalk.blue(`\nüîÑ Rolling back: ${modId}\n`));
    
    const result = await this.rollbackHandler.rollback(modId, {
      partial: config.partial,
      preserveBackup: config.preserveBackup,
      verify: config.verify
    });

    console.log(chalk.green(`\n‚úÖ Rollback completed successfully!`));
    console.log(chalk.gray(`  Files restored: ${result.filesRestored}`));
    console.log(chalk.gray(`  Backup preserved: ${config.preserveBackup}`));
    
    if (config.verify) {
      console.log(chalk.gray(`  Verification: ${result.verified ? 'PASSED' : 'FAILED'}`));
    }

    return result;
  }
}

module.exports = RollbackModificationTask;
```

## Integration Points

### Rollback Handler
- Tracks modification history
- Manages backup files
- Executes rollback operations
- Verifies rollback integrity

### Modification Tracking
- Records all framework modifications
- Maintains modification timeline
- Links modifications to backups

### Backup Management
- Creates automatic backups
- Preserves modification history
- Enables point-in-time recovery

## Rollback Types

### Full Rollback
- Restores all modified files
- Reverts all changes from modification
- Complete state restoration

### Partial Rollback
- Selective file restoration
- Rollback specific changes only
- Preserves unaffected changes

### Checkpoint Rollback
- Restore to named checkpoint
- Rollback multiple modifications
- Time-based restoration

## Safety Guarantees

### Pre-Rollback Checks
- Modification exists in history
- Backup files available
- No conflicting changes

### During Rollback
- Atomic operations where possible
- Transaction support
- Error recovery

### Post-Rollback
- Verification of restored state
- Backup preservation option
- Audit trail maintained

## Best Practices

### When to Rollback
- Modification causes errors
- Breaking changes detected
- Performance degradation
- Security issues identified

### Rollback Process
1. Identify modification to rollback
2. Review modification details
3. Confirm rollback decision
4. Execute with verification
5. Test restored functionality
6. Document rollback reason

### After Rollback
- Analyze what went wrong
- Update modification approach
- Learn from failure
- Update safety checks

