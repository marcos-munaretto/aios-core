# Update Tests - QA Task

## Execution Dependencies
**Utils:** test-updater

## Purpose
Update existing test suites to match code changes, ensuring tests remain aligned with implementation and maintain coverage.

## Command Pattern
```
*update-tests <test-file> [options]
```

## Parameters
- `test-file`: Test file to update
- `options`: Update configuration

### Options
- `--target <file>`: Source file that changed (auto-detect if not provided)
- `--sync`: Sync test with current implementation
- `--add-cases`: Add missing test cases
- `--fix-assertions`: Fix broken assertions
- `--update-mocks`: Update mocks to match new interfaces
- `--dry-run`: Preview changes without applying

## Examples
```bash
# Update tests for changed component
*update-tests tests/unit/components/Button.test.js

# Sync tests with source file
*update-tests tests/integration/auth.test.js --sync

# Add missing test cases
*update-tests tests/unit/parser.test.js --add-cases

# Fix broken assertions after refactor
*update-tests tests/integration/api.test.js --fix-assertions

# Update mocks after interface change
*update-tests tests/unit/service.test.js --update-mocks

# Preview changes
*update-tests tests/unit/utils.test.js --dry-run
```

## Implementation

### 1. Analyze Test File
```javascript
const testUpdater = require('../scripts/test-updater');

// Load test file
const testPath = args.testFile;
const testCode = await fs.readFile(testPath, 'utf8');

// Parse test structure
const testAnalysis = testUpdater.analyzeTest({
  code: testCode,
  path: testPath
});
```

### 2. Detect Changes
```javascript
// Find corresponding source file
const sourcePath = args.target || testUpdater.inferSourcePath(testPath);
const sourceCode = await fs.readFile(sourcePath, 'utf8');

// Analyze changes
const changes = await testUpdater.detectChanges({
  testCode: testAnalysis,
  sourceCode: sourceCode,
  testPath: testPath,
  sourcePath: sourcePath
});
```

### 3. Generate Updates
```javascript
// Generate test updates
const updates = await testUpdater.generateUpdates({
  changes: changes,
  options: {
    sync: args.sync || false,
    addCases: args.addCases || false,
    fixAssertions: args.fixAssertions || false,
    updateMocks: args.updateMocks || false
  }
});
```

### 4. Apply Updates
```javascript
// Apply or preview
if (args.dryRun) {
  console.log('Preview of changes:');
  console.log(testUpdater.formatUpdates(updates));
} else {
  await testUpdater.applyUpdates({
    testPath: testPath,
    updates: updates
  });
  
  console.log(`✅ Test file updated: ${testPath}`);
  console.log(`   - ${updates.length} changes applied`);
}
```

## Update Types

### Sync Mode
```javascript
// Sync test with current source implementation
*update-tests tests/unit/calculator.test.js --sync

// Updates:
// - Adds tests for new methods
// - Removes tests for deleted methods
// - Updates test descriptions
// - Syncs mock interfaces
```

### Add Missing Cases
```javascript
// Add test cases for uncovered scenarios
*update-tests tests/integration/api.test.js --add-cases

// Adds:
// - Edge case tests
// - Error condition tests
// - Boundary tests
// - Missing code paths
```

### Fix Assertions
```javascript
// Fix broken assertions after refactoring
*update-tests tests/unit/service.test.js --fix-assertions

// Fixes:
// - Updated return types
// - Changed property names
// - New error messages
// - Modified behavior
```

### Update Mocks
```javascript
// Update mocks after interface changes
*update-tests tests/unit/client.test.js --update-mocks

// Updates:
// - Mock function signatures
// - Mock return values
// - Mock implementations
// - Spy expectations
```

## Change Detection

### New Methods/Functions
```javascript
// Detected: New function added to source
// Action: Generate test case for new function
describe('newFunction', () => {
  it('should handle valid input', () => {
    // Generated test
  });
});
```

### Modified Signatures
```javascript
// Detected: Function signature changed
// Action: Update test calls and assertions
// Before: function(a, b)
// After: function(config)
expect(fn({ a: 1, b: 2 })).toBe(expected);
```

### Removed Methods
```javascript
// Detected: Method no longer exists
// Action: Comment out or remove obsolete tests
// describe.skip('deletedMethod', () => { ... });
```

### Changed Behavior
```javascript
// Detected: Implementation logic changed
// Action: Update assertions to match new behavior
expect(result).toBe(newExpectedValue);
```

## Validation

### Verify Updates
```javascript
// Validate updated tests
*update-tests tests/unit/component.test.js --validate

// Checks:
// - Syntax validity
// - No broken imports
// - Assertions logical
// - Mocks compatible
```

### Run Updated Tests
```javascript
// Run tests after update
npm test tests/unit/component.test.js

// Verify:
// - All tests pass
// - Coverage maintained/improved
// - No regressions
```

## Error Handling

### Test File Not Found
```javascript
if (!fs.existsSync(testPath)) {
  throw new Error(`Test file not found: ${testPath}`);
}
```

### Source Not Detected
```javascript
if (!sourcePath) {
  console.warn('⚠️ Could not auto-detect source file');
  console.log('Please specify with --target flag');
  return;
}
```

### Update Conflicts
```javascript
if (updates.conflicts.length > 0) {
  console.warn('⚠️ Manual review needed for:');
  updates.conflicts.forEach(c => console.log(`   - ${c.description}`));
}
```

## Best Practices

1. **Review Before Applying** - Use `--dry-run` to preview changes
2. **Sync Regularly** - Keep tests in sync with source using `--sync`
3. **Run Tests After** - Always execute tests after updates
4. **Manual Review** - Review automated updates for accuracy
5. **Commit Separately** - Commit test updates separately from code changes

## Integration with test-generator

### Workflow
```javascript
// 1. Code changes made
// 2. Update tests
*update-tests tests/unit/component.test.js --sync

// 3. Add missing cases if needed
*update-tests tests/unit/component.test.js --add-cases

// 4. Verify tests pass
npm test tests/unit/component.test.js
```

## Related Commands

- `*generate-tests` - Generate new test suites (uses test-generator utility)
- `*review` - QA review (uses test-quality-assessment utility)

## Notes

- test-updater uses intelligent diff analysis to detect changes
- Preserves manually written test logic
- Updates only what's necessary
- Integrates with test-quality-assessment for coverage analysis
- Supports multiple testing frameworks (jest, mocha, vitest)


